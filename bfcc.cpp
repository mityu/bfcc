// TODO: 
// - Add comment at the top of the intermediate-file
// - Use for loop for '+', '-', '<', '>', '.' and ',' command
// - Compile automatically
#include <iostream>
#include <string>
#include <fstream>
#include <vector>

std::string IntermediateCode = R"(
// This C++ source code is automatically generated by bfcc.
// The license is NYSL.
#include <iostream>
#include <string>
#include <fstream>
#include <vector>

class Buffer {
public:
	Buffer() : index_(0) {
		buf_.push_back(0);
	}
	void nextPtr() {
		if (++index_ == buf_.size()) {
			buf_.push_back(0);
		}
	}
	void prevPtr() {
		if (index_-- == 0) {
			buf_.insert(buf_.begin(), 0);
		}
	}
	void increment() {
		buf_[index_]++;
	}
	void decrement() {
		buf_[index_]--;
	}
	void serValue(char c) {
		buf_[index_] = c;
	}
	char getValue() const {
		return buf_[index_];
	}
private:
	std::vector<char> buf_;
	std::size_t index_;
};

int main() {
	Buffer buf;
)";


std::string make_indent(const std::string code, unsigned int indent) {
    std::string str(code);
    std::string indent_str;
    for (int i = 0; i < indent; ++i) {
        indent_str += "\t";
    }
    indent_str = indent_str;

    int count = 0;
    for (char c : code) {
        if (c == '\n') {
            count++;
        }
    }
    str.reserve(code.length() + count * indent_str.length());

    for (std::string::size_type begin = 0, end = std::string::npos;;) {
        end = code.find_first_of('\n');
        if (end == std::string::npos) {
            break;
        }
        str += indent_str + code.substr(begin, end);
        begin = end;
    }


    return indent_str + str + "\n";
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        std::cerr << "Too few arguments" << std::endl;
        return -1;
    }

    const std::string source_file = argv[1];
    const std::string intermediate_file = source_file + ".cpp";
    std::ifstream source(source_file);
    if (!source) {
        std::cerr << "Cannot read " << source_file << std::endl;
        return -1;
    }

    std::string source_code;
    {
        char c;
        while (source.get(c)) {
            if (c == '.' || c == '+' || c == '-' || c == '<' || c == '>' ||
                    c == '[' || c == ']' || c == ',') {
                source_code += c;
            }
        }
        if (!source.eof()) {
            std::cerr << "File read error: " << source_file << std::endl;
        }
    }

    unsigned int indent = 1;
    for (int i = 0; i < source_code.size(); ++i) {
        char c = source_code[i];
        switch (c) {
        case '.':
            IntermediateCode += make_indent("std::cout << buf.getValue();", indent);
            break;
        case '+':
            IntermediateCode += make_indent("buf.increment();", indent);
            break;
        case '-':
            IntermediateCode += make_indent("buf.decrement();", indent);
            break;
        case '<':
            IntermediateCode += make_indent("buf.prevPtr();", indent);
            break;
        case '>':
            IntermediateCode += make_indent("buf.nextPtr();", indent);
            break;
        case '[':
            IntermediateCode += make_indent("while (static_cast<int>(buf.getValue())) {", indent);
            indent++;
            break;
        case ']':
            indent--;
            IntermediateCode += make_indent("}", indent);
            break;
        case ',':
            IntermediateCode += make_indent("{\n\tchar input;\n\tstd::cin >> std::setw(1) >> input;\n\tbuf.serValue(input);\n}", indent);
            break;
        default:
            std::cerr << "Cannot reach here" << std::endl;
            return -1;
            // Cannot reach here
        }
    }
    IntermediateCode += "\tstd::cout << std::endl;\n}";

    std::ofstream ofs(intermediate_file);
    if (!ofs) {
        std::cerr << "Open intermediate-file failed" << std::endl;
        return -1;
    }
    ofs << IntermediateCode << std::endl;;
}
